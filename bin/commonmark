#!/usr/bin/env node
"use strict";

var util = require('util');
var fs = require('fs');
var commonmark = require('../lib/index.js');
var version = require('../package.json').version;
var parseArgs = require('minimist');
const path = require('path');

const toc = require('../addons/toc.js');
const question = require('../addons/question.js');
const localAnchor = require('../addons/localanchor.js');
const include = require('../addons/include.js');
const attr = require('../addons/attr.js');
const examRadio = require('../addons/radio.js');

// get arguments
var args = process.argv.slice(2);
var argv = parseArgs(args,
  {boolean: ["ast", "xml", "time", "smart",
             "safe", "sourcepos", "help", "version", "tree"],
   string: ["to", "t"],
   unknown: function(o) {
     if (/^-/.test(o)) {
      process.stderr.write("Unknown option " + o + "\n");
      process.exit(1);
     }
   }
  });

var inps = [];
var i;

var usage = function() {
    process.stdout.write("commonmark [options] [file..]\n\n" +
    "Convert CommonMark to HTML.  Files are concatenated before\n" +
    "parsing.  If no files are given, input is read from stdin.\n\n" +
    "-t,--to FORMAT  Specify output format (xml, html, ast)\n" +
    "--time          Produce timings for phases of parsing and rendering\n" +
    "--smart         Parse 'smart' punctuation\n" +
    "--tree         output parse tree\n" +
    "--safe          Omit raw HTML and potentially unsafe attributes\n" +
    "--sourcepos     Include source position attributes in HTML tags\n" +
    "--version       Print version information\n" +
    "--help          Print usage information\n");
    process.exit(0);
};

if (argv.help) {
    usage();
    process.exit(0);
}
if (argv.version) {
    process.stdout.write('commonmark.js ' + version + '\n');
    process.exit(0);
}

var format = argv.to || argv.t || (argv.xml ? 'xml' :
                                      (argv.ast ? 'ast' : 'html'));

var options = {
    time: argv.time,
    smart: argv.smart,
    safe: argv.safe,
    sourcepos: argv.sourcepos
};

var files = argv._;

var parser = new commonmark.Parser(options);
var renderer;
var htmlRenderer = null;
var xmlRenderer = null;

if (format === 'html') {
    renderer = new commonmark.HtmlRenderer(options);
    htmlRenderer = renderer;
} else if (format === 'xml') {
    renderer = new commonmark.XmlRenderer(options);
    xmlRenderer = renderer;
} else if (format === 'ast') {
    renderer = { render: function(node) {
                   return util.inspect(node, null, 20, true) + '\n';
                 },
                 options: {} };
} else if (format === 'tree') {
    renderer = { render: function(node) {
                   return util.inspect(node, null, 20, true) + '\n';
                 },
                 options: {} };
} else {
    process.stderr.write("Unknown format: " + format + "\n");
    process.exit(1);
}
toc(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);
question(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
localAnchor(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
include(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);
attr.install(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
examRadio(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);

if (files.length === 0) {
  files = ['/dev/stdin'];
}

for (i = 0; i < files.length; i++) {
  var file = files[i];
  inps.push(fs.readFileSync(file, 'utf8'));
}

const basepath = (files.length == 1 ? files[0] : undefined);
parser.setPath(path.resolve(path.dirname(basepath)));

var inp = inps.join('\n');
var doc = parser.parse(inp);

if (argv.tree) {
    var tree = doc.asstring();
    process.stdout.write(tree);
}

doc = attr.rearrange(doc);
//console.log(doc.asstring(true));

var rendered = renderer.render(doc);

if (!options.time) { process.stdout.write(rendered); }
