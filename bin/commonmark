#!/usr/bin/env node
"use strict";

var util = require('util');
var fs = require('fs');
var commonmark = require('../lib/index.js');
var version = require('../package.json').version;
var parseArgs = require('minimist');
const path = require('path');

const toc = require('../addons/toc.js');
const question = require('../addons/question.js');
const localAnchor = require('../addons/localanchor.js');
const include = require('../addons/include.js');
const attr = require('../addons/attr.js');
const examRadio = require('../addons/radio.js');
const table = require('../addons/table.js');
const ExamRenderer = require('../addons/exam.js');

// get arguments
var args = process.argv.slice(2);
var argv = parseArgs(args,
		     {boolean: ["ast", "xml", "time", "smart", "nostdout", 
             "safe", "sourcepos", "help", "version", "tree"],
		      string: ["to", "t", "outdir"],
   unknown: function(o) {
     if (/^-/.test(o)) {
      process.stderr.write("Unknown option " + o + "\n");
      process.exit(1);
     }
   }
  });

var inps = [];
var i;

var usage = function() {
    process.stdout.write("commonmark [options] [file..]\n\n" +
    "Convert CommonMark to HTML.  Files are concatenated before\n" +
    "parsing.  If no files are given, input is read from stdin.\n\n" +
    "-t,--to FORMAT  Specify output format (xml, html, ast, exam)\n" +
    "--time          Produce timings for phases of parsing and rendering\n" +
    "--smart         Parse 'smart' punctuation\n" +
    "--tree          output parse tree\n" +
    "--safe          Omit raw HTML and potentially unsafe attributes\n" +
    "--sourcepos     Include source position attributes in HTML tags\n" +
    "--nostdout      Don't output results to stdout, use filename\n" +
    "--outdir DIR    path to place to put files if --nostdout\n" +
    "--version       Print version information\n" +
    "--help          Print usage information\n");
    process.exit(0);
};

if (argv.help) {
    usage();
    process.exit(0);
}
if (argv.version) {
    process.stdout.write('commonmark.js ' + version + '\n');
    process.exit(0);
}

const format = argv.to || argv.t || (argv.xml ? 'xml' :
                                      (argv.ast ? 'ast' : 'html'));

const outExtension = "."+(format == 'exam' ? 'html' : format);

var options = {
    time: argv.time,
    smart: argv.smart,
    safe: argv.safe,
    sourcepos: argv.sourcepos
};

var files = argv._;

var parser = new commonmark.Parser(options);
var renderer;
var htmlRenderer = null;
var xmlRenderer = null;

if ((format === 'html')||(format === 'exam')) {
    renderer = new commonmark.HtmlRenderer(options);
    htmlRenderer = renderer;
} else if (format === 'xml') {
    renderer = new commonmark.XmlRenderer(options);
    xmlRenderer = renderer;
} else if (format === 'ast') {
    renderer = { render: function(node) {
                   return util.inspect(node, null, 20, true) + '\n';
                 },
                 options: {} };
} else if (format === 'tree') {
    renderer = { render: function(node) {
                   return util.inspect(node, null, 20, true) + '\n';
                 },
                 options: {} };
} else {
    process.stderr.write("Unknown format: " + format + "\n");
    process.exit(1);
}
toc(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);
question(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
localAnchor(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
include(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);
attr(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
examRadio.blocks(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);
examRadio.inlines(parser.addParserFunction('inline'), htmlRenderer, xmlRenderer);
table(parser.addParserFunction('block'), htmlRenderer, xmlRenderer);

if (files.length === 0) {
    files = ['/dev/stdin'];
}

const basepath = (files.length == 1 ? files[0] : undefined);
parser.setPath(path.resolve(path.dirname(basepath)));

let outbasename = "";
let outfile = process.stdout;
if (argv.nostdout) {
    if (files.length !== 1) {
	process.stderr.write("When --nostdout set, must have exactly one input file set\n");
	process.exit(1);
    }
    outbasename = path.resolve(argv.outdir, path.basename(basepath, ".md"));
    outfile = fs.createWriteStream(outbasename+outExtension);
} 

for (i = 0; i < files.length; i++) {
  var file = files[i];
  inps.push(fs.readFileSync(file, 'utf8'));
}

var inp = inps.join('\n');
var doc = parser.parse(inp);

if (argv.tree) {
    var tree = doc.asstring();
    process.stdout.write(tree);
}

var rendered = renderer.render(doc);

if (!options.time) { outfile.write(rendered); }

if (format == 'exam') {
    const erender = new ExamRenderer(options);
    const examoutput = erender.render(doc);
    const numqs = erender.getNumQuestions();
    if (argv.nostdout)
	outfile = fs.createWriteStream(outbasename+'.exam');

    if (numqs > 0) {
	const headeroutput = erender.getHeader();
	if (erender.checkExamTypes()) {
	    process.stderr.write('There are '+numqs+' blanks/MC/Etc. in this question.\n');
	    outfile.write('\n----- EXAM INFO -----\n');
	    outfile.write(headeroutput);
	    outfile.write(examoutput);
	} else {
	    process.stderr.write('Error in solution blocks: '+headeroutput);
	}
    } else {
	outfile.write('No questions\n');
    }
}
